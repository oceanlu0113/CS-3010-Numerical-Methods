# -*- coding: utf-8 -*-
"""[CS3010.01] Project 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LFAN_636FjU95JrHzYgltZuvYlvwxWcO
"""

# Bisection Method

def f(x):
    return (x**3 + 2*x**2 + 10*x - 20)

def bisection_method(a, b, tol):
    counter = 1
    print("Bisection Method:")
    if f(a)*f(b) > 0:
        print("No root found.")
    else:
        while (b - a)/2.0 > tol:
            midpoint = (a + b)/2.0
            if f(midpoint) == 0:
                return(midpoint)
            elif f(a)*f(midpoint) < 0:
                b = midpoint
            else:
                a = midpoint
            print("Step", counter)
            print("Value of Root:", midpoint)
            print("Value of Function:", f(midpoint))
            print("Error:", (b - a)/2.0, "\n")
            counter = counter + 1
        return(midpoint)

a = 1
b = 2
E = 0.000005
answer = bisection_method(a, b, E)

print("Final answer:", answer)

# False Position Method

import math
import numpy as np

def f(x):
    return (x**3 + 2*x**2 + 10*x - 20)

def regulaFalsi(a,b,TOL):
    print("False Position Method:")
    i = 1
    FA = f(a)
    while True:
        p = (a*f(b)-b*f(a))/(f(b) - f(a))
        FP = f(p)
        if(FP == 0 or np.abs(f(p)) < TOL):
            break
        else:
            print("Step", i)
            print ("Value of Root:", a)
            print("Value of Function:",f(a))
            print("Error:", np.abs(f(p)), "\n")
        i = i + 1
        if(FA*FP > 0):
            a = p
        else:
            b = p
    print("Final answer: ", a)

a = 1
b = 2
E = 0.000005
regulaFalsi(a, b, E)

# Newton Method

def f(x):
    return (x**3 + 2*x**2 + 10*x - 20)
def df( x ): 
	  return (3*x**2 + 4*x + 10)

def newtonRaphson(x, TOL): 
    i = 1
    h = f(x) / df(x)
    print("Newton Method:")
    while abs(h) >= TOL: 
      h = f(x)/df(x) 
      x = x - h
      print("Step", i)
      print("Value of Root:", x)
      print("Value of Function:", f(x))
      print("Error:", h, "\n")
      i = i + 1
    print("Final answer:", x) 

x0 = 2
E = 0.000005
newtonRaphson(x0, E)

# Secant method

def f(x):
    return (x**3 + 2*x**2 + 10*x - 20)

def secant(x1, x2, E): 
    print("Secant Method:")
    n = 0; xm = 0; x0 = 0; c = 0; 
    if (f(x1) * f(x2) < 0): 
      while True: 
        x0 = ((x1 * f(x2) - x2 * f(x1)) /	(f(x2) - f(x1)));
        c = f(x1) * f(x0); 
        x1 = x2; 
        x2 = x0; 
        n += 1; 
        print("Step", n)
        print("Value of Root:", x0)
        print("Value of Function:", c)
        if (c == 0): 
          break; 
        xm = ((x1 * f(x2) - x2 * f(x1)) /	(f(x2) - f(x1))); 
        print("Error:", abs(xm - x0), "\n")
        if(abs(xm - x0) < E): 
          break;
    else: 
      print("Can not find a root in ", "the given inteval"); 
    print("Final answer:", x0)

x0 = 2; 
x1 = 1; 
E = 0.000005; 
secant(x0, x1, E);